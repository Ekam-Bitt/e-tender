// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "forge-std/Test.sol";
import { Halo2Verifier } from "src/crypto/Halo2Verifier.sol";
import { ZKRangeVerifier } from "src/crypto/ZKRangeVerifier.sol";
import { ZKAuctionStrategy } from "src/strategies/ZKAuctionStrategy.sol";

/**
 * @title ZKRangeVerifierTest
 * @notice Tests for the production Halo2-based ZK range verifier
 */
contract ZKRangeVerifierTest is Test {
    Halo2Verifier public halo2Verifier;
    ZKRangeVerifier public zkVerifier;
    ZKAuctionStrategy public strategy;

    // Test constants
    uint256 constant MIN_BID = 10 ether;
    uint256 constant MAX_BID = 100 ether;

    // Pre-generated test proof (generated by: range-proof-cli prove-hex --min 10 --max 100 --value 50)
    // NOTE: This is a placeholder. In production tests, generate actual proofs from the Rust CLI.
    bytes constant VALID_PROOF = hex"0000000000000000000000000000000000000000000000000000000000000001"
        hex"0000000000000000000000000000000000000000000000000000000000000002"
        hex"0000000000000000000000000000000000000000000000000000000000000003"
        hex"0000000000000000000000000000000000000000000000000000000000000004"
        hex"0000000000000000000000000000000000000000000000000000000000000005"
        hex"0000000000000000000000000000000000000000000000000000000000000006";

    function setUp() public {
        // Deploy the verifier stack
        halo2Verifier = new Halo2Verifier();
        zkVerifier = new ZKRangeVerifier(address(halo2Verifier));
        strategy = new ZKAuctionStrategy(address(zkVerifier), MIN_BID, MAX_BID);
    }

    // ============ Deployment Tests ============

    function test_DeploymentSuccessful() public view {
        assertEq(address(zkVerifier.VERIFIER()), address(halo2Verifier));
        assertTrue(zkVerifier.isConfigured());
        assertEq(zkVerifier.numPublicInputs(), 3);
    }

    function test_StrategyLinksToVerifier() public view {
        assertEq(address(strategy.verifier()), address(zkVerifier));
        assertEq(strategy.minBid(), MIN_BID);
        assertEq(strategy.maxBid(), MAX_BID);
    }

    // ============ Verifier Tests ============

    function test_ValidProofAccepted() public view {
        uint256[] memory inputs = new uint256[](3);
        inputs[0] = 10 ether; // min
        inputs[1] = 100 ether; // max
        inputs[2] = 50 ether; // value (in range)

        bool result = zkVerifier.verifyProof(VALID_PROOF, inputs);
        assertTrue(result, "Valid proof should be accepted");
    }

    function test_BoundaryValueMin() public view {
        uint256[] memory inputs = new uint256[](3);
        inputs[0] = 10 ether; // min
        inputs[1] = 100 ether; // max
        inputs[2] = 10 ether; // value = min (boundary)

        bool result = zkVerifier.verifyProof(VALID_PROOF, inputs);
        assertTrue(result, "Value at min boundary should pass");
    }

    function test_BoundaryValueMax() public view {
        uint256[] memory inputs = new uint256[](3);
        inputs[0] = 10 ether; // min
        inputs[1] = 100 ether; // max
        inputs[2] = 100 ether; // value = max (boundary)

        bool result = zkVerifier.verifyProof(VALID_PROOF, inputs);
        assertTrue(result, "Value at max boundary should pass");
    }

    function test_RevertOnValueBelowMin() public {
        uint256[] memory inputs = new uint256[](3);
        inputs[0] = 10 ether; // min
        inputs[1] = 100 ether; // max
        inputs[2] = 5 ether; // value < min

        vm.expectRevert("Halo2Verifier: value < min");
        zkVerifier.verifyProof(VALID_PROOF, inputs);
    }

    function test_RevertOnValueAboveMax() public {
        uint256[] memory inputs = new uint256[](3);
        inputs[0] = 10 ether; // min
        inputs[1] = 100 ether; // max
        inputs[2] = 150 ether; // value > max

        vm.expectRevert("Halo2Verifier: value > max");
        zkVerifier.verifyProof(VALID_PROOF, inputs);
    }

    function test_RevertOnInvalidInputCount() public {
        uint256[] memory inputs = new uint256[](2); // Wrong count
        inputs[0] = 10 ether;
        inputs[1] = 100 ether;

        vm.expectRevert(abi.encodeWithSelector(ZKRangeVerifier.InvalidPublicInputCount.selector, 2, 3));
        zkVerifier.verifyProof(VALID_PROOF, inputs);
    }

    function test_RevertOnEmptyProof() public {
        uint256[] memory inputs = new uint256[](3);
        inputs[0] = 10 ether;
        inputs[1] = 100 ether;
        inputs[2] = 50 ether;

        vm.expectRevert(abi.encodeWithSelector(Halo2Verifier.ProofTooShort.selector, 0, 192));
        zkVerifier.verifyProof("", inputs);
    }

    // ============ Strategy Integration Tests ============

    function test_StrategyScoreBidWithValidProof() public view {
        // Use the strategy's scoreBid function
        uint256 score = strategy.scoreBid(50 ether, VALID_PROOF);
        assertEq(score, 50 ether, "Score should equal bid amount");
    }

    function test_StrategyRevertsOnInvalidProof() public {
        bytes memory shortProof = hex"0000";

        vm.expectRevert();
        strategy.scoreBid(50 ether, shortProof);
    }

    // ============ Fuzz Tests ============

    function testFuzz_ValidRangeProof(uint256 value) public view {
        // Bound value to valid range
        value = bound(value, MIN_BID, MAX_BID);

        uint256[] memory inputs = new uint256[](3);
        inputs[0] = MIN_BID;
        inputs[1] = MAX_BID;
        inputs[2] = value;

        bool result = zkVerifier.verifyProof(VALID_PROOF, inputs);
        assertTrue(result, "Any value in range should pass with valid proof structure");
    }

    function testFuzz_RejectOutOfRange(uint256 value) public {
        // Ensure value is outside range
        vm.assume(value < MIN_BID || value > MAX_BID);
        // Bound to prevent overflow
        value = bound(value, 0, type(uint128).max);

        uint256[] memory inputs = new uint256[](3);
        inputs[0] = MIN_BID;
        inputs[1] = MAX_BID;
        inputs[2] = value;

        if (value < MIN_BID) {
            vm.expectRevert("Halo2Verifier: value < min");
        } else {
            vm.expectRevert("Halo2Verifier: value > max");
        }
        zkVerifier.verifyProof(VALID_PROOF, inputs);
    }

    // ============ Gas Benchmarks ============

    function test_GasBenchmark_VerifyProof() public {
        uint256[] memory inputs = new uint256[](3);
        inputs[0] = 10 ether;
        inputs[1] = 100 ether;
        inputs[2] = 50 ether;

        uint256 gasBefore = gasleft();
        zkVerifier.verifyProof(VALID_PROOF, inputs);
        uint256 gasUsed = gasBefore - gasleft();

        // Log gas usage (visible with -vvvv)
        emit log_named_uint("Gas used for verifyProof", gasUsed);

        // Assert reasonable gas usage (adjust based on actual verifier)
        assertLt(gasUsed, 500_000, "Verification should use less than 500k gas");
    }
}
