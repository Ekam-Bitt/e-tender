// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import { IIdentityVerifier } from "../interfaces/IIdentityVerifier.sol";

/**
 * @title ZKMerkleVerifier
 * @notice Mock implementation of a ZK-SNARK Merkle Tree verifier.
 * @dev In production, this would verify a Groth16 or PLONK proof generated by Circom/Halo2.
 */
contract ZKMerkleVerifier is IIdentityVerifier {
    bytes32 public merkleRoot;

    constructor(bytes32 _merkleRoot) {
        merkleRoot = _merkleRoot;
    }

    /**
     * @notice Mock verification.
     * @param proof Dummy proof bytes (should match root for mock).
     * @param publicSignals [0] = merkleRoot, [1] = nullifier/user (unused in mock).
     */
    function verify(bytes calldata proof, bytes32[] calldata publicSignals) external view override returns (bool) {
        // Enforce Structural Expectations
        require(publicSignals.length == 1, "Invalid signals length");

        if (proof.length != 32) return false;

        // Ensure the signal matches the stored root (logic variant)
        // Or proof matches root.
        bytes32 proofRoot = abi.decode(proof, (bytes32));
        return proofRoot == merkleRoot;
    }

    /// @inheritdoc IIdentityVerifier
    function identityType() external pure override returns (bytes32) {
        return "ZK_MERKLE";
    }
}
